###############################################################################
# SPDX-License-Identifier: GPL-3.0-only
# PURPOSE: Look for multiple unique index files
###############################################################################
sub nikto_multiple_index_init {
    my $id = { name        => "multiple_index",
               full_name   => "Multiple Index",
               author      => "Tautology",
               description => "Checks for multiple index files",
               hooks       => { scan => { method => \&nikto_multiple_index, }, },
               copyright   => "2009 Chris Sullo"
               };

    return $id;
}

sub nikto_multiple_index {
    my ($mark) = @_;
    my $dbarray = init_db("db_multiple_index");
    my ($found, $hashes);
    foreach my $item (@$dbarray) {
        return if $mark->{'terminate'};

        # Get file
        my ($res, $content, $error, $request, $response) =
          nfetch($mark, "/$item->{'index'}", "GET", "", "", "", "multiple_index");

        if ($res == 200) {
            $content = rm_active_content($content, "$mark->{'root'}/$item->{'index'}");
            my $hash = LW2::md5($content);
            $found{"$mark->{'root'}/$item->{'index'}"} = $hash;
            $hashes{$hash}++;
        }

    }

    my $count = keys(%found);
    if ($count > 1) {

        # make sure we have unique pages
        my $total_unique = grep { $hashes{$_} == 1 } keys %hashes;

        # one unique hash... bogus responses
        if ($total_unique <= 1) {
            return;
        }
        my $file_list = join(', ', keys %found);

        my $msg = "Multiple index files found";
        if ($total_unique < $count) {
            $msg .= " (may not all be unique)";
        }
        else {
            $msg .= " (all unique)";
        }
        add_vulnerability($mark, "$msg: $file_list", "740000", "", "GET", "/", $request, $response);
    }
}

1;
